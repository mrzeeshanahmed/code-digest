Directory: Code Digest
Files analyzed: 14
Generated: 2025-08-12T10:25:06.395Z
Estimated tokens: 5.6k

Directory structure:
└── Code Digest/
    ├── src/
    │   ├── panels/
    │   │   └── SidebarProvider.ts
    │   ├── utils/
    │   │   ├── binary.ts
    │   │   ├── DigestGenerator.ts
    │   │   ├── ignore.ts
    │   │   ├── tokens.ts
    │   │   └── tree.ts
    │   ├── webview/
    │   │   ├── index.html
    │   │   ├── main.js
    │   │   └── styles.css
    │   └── extension.ts
    ├── package-lock.json
    ├── package.json
    ├── README.md
    └── tsconfig.json

================================================
FILE: package-lock.json
================================================
{
  "name": "code-digest",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "code-digest",
      "version": "1.0.0",
      "dependencies": {
        "ignore": "^5.3.2",
        "minimatch": "^9.0.5"
      },
      "devDependencies": {
        "@types/node": "^18.19.122",
        "@types/vscode": "^1.102.0",
        "typescript": "^5.0.0"
      },
      "engines": {
        "node": "^18.0.0",
        "vscode": "^1.85.0"
      }
    },
    "node_modules/@types/node": {
      "version": "18.19.122",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-18.19.122.tgz",
      "integrity": "sha512-yzegtT82dwTNEe/9y+CM8cgb42WrUfMMCg2QqSddzO1J6uPmBD7qKCZ7dOHZP2Yrpm/kb0eqdNMn2MUyEiqBmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~5.26.4"
      }
    },
    "node_modules/@types/vscode": {
      "version": "1.102.0",
      "resolved": "https://registry.npmjs.org/@types/vscode/-/vscode-1.102.0.tgz",
      "integrity": "sha512-V9sFXmcXz03FtYTSUsYsu5K0Q9wH9w9V25slddcxrh5JgORD14LpnOA7ov0L9ALi+6HrTjskLJ/tY5zeRF3TFA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.2",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.2.tgz",
      "integrity": "sha512-CWBzXQrc/qOkhidw1OzBTQuYRbfyxDXJMVJ1XNwUHGROVmuaeiEm3OslpZ1RV96d7SKKjZKrSJu3+t/xlw3R9A==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "5.26.5",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-5.26.5.tgz",
      "integrity": "sha512-JlCMO+ehdEIKqlFxk6IfVoAUVmgz7cU7zD/h9XZ0qzeosSHmUJVOzSQvvYSYWXkFXC+IfLKSIffhv0sVZup6pA==",
      "dev": true,
      "license": "MIT"
    }
  }
}


================================================
FILE: package.json
================================================
{
  "name": "code-digest",
  "displayName": "Code Digest",
  "description": "Generate Gitingest-style prompt-friendly code digests",
  "version": "1.0.0",
  "publisher": "your-publisher",
  "engines": {
    "vscode": "^1.85.0",
    "node": "^18.0.0"
  },
  "categories": [
    "Other"
  ],
  "main": "./out/extension.js",
  "contributes": {
    "commands": [
      {
        "command": "codeDigest.create",
        "title": "Code Digest: Create Digest"
      }
    ],
    "viewsContainers": {
      "activitybar": [
        {
          "id": "codeDigest",
          "title": "Code Digest",
          "icon": "resources/icon.png"
        }
      ]
    },
    "views": {
      "codeDigest": [
        {
          "id": "codeDigest.view",
          "name": "Code Digest",
          "type": "webview",
          "icon": "resources/icon.png",
          "when": "workbenchState != empty"
        }
      ]
    },
    "configuration": {
      "title": "Code Digest",
      "properties": {
        "codeDigest.outputFileName": {
          "type": "string",
          "default": "digest.txt",
          "description": "Name of the output file (supports .txt or .md)"
        },
        "codeDigest.mode": {
          "type": "string",
          "enum": [
            "curated",
            "allText"
          ],
          "default": "curated",
          "description": "File inclusion mode"
        },
        "codeDigest.respectGitignore": {
          "type": "boolean",
          "default": true,
          "description": "Respect .gitignore and apply default excludes"
        },
        "codeDigest.includeDotfiles": {
          "type": "boolean",
          "default": true,
          "description": "Include dotfiles and config files"
        },
        "codeDigest.includeGitDir": {
          "type": "boolean",
          "default": false,
          "description": "Include .git directory"
        },
        "codeDigest.maxFileSizeKB": {
          "type": "number",
          "default": 10240,
          "description": "Maximum file size in KB"
        },
        "codeDigest.includeBinary": {
          "type": "boolean",
          "default": false,
          "description": "Include binary files (as base64 if needed)"
        },
        "codeDigest.additionalIncludeGlobs": {
          "type": "array",
          "default": [],
          "description": "Additional glob patterns to include"
        },
        "codeDigest.additionalExcludeGlobs": {
          "type": "array",
          "default": [],
          "description": "Additional glob patterns to exclude"
        },
        "codeDigest.markdownCodeFences": {
          "type": "boolean",
          "default": false,
          "description": "Use markdown code fences for content blocks"
        }
      }
    }
  },
  "scripts": {
    "vscode:prepublish": "npm run compile",
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./"
  },
  "devDependencies": {
    "@types/node": "^18.19.122",
    "@types/vscode": "^1.102.0",
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "ignore": "^5.3.2",
    "minimatch": "^9.0.5"
  }
}


================================================
FILE: README.md
================================================
# Code Digest Extension

A VS Code extension for code digest features.

## Structure

```
├── package.json
├── tsconfig.json
├── src/
│   ├── extension.ts
│   ├── panels/
│   │   └── SidebarProvider.ts
│   ├── utils/
│   │   ├── ignore.ts
│   │   ├── tree.ts
│   │   ├── binary.ts
│   │   └── tokens.ts
│   └── webview/
│       ├── index.html
│       ├── main.js
│       └── styles.css
└── README.md
```


# Code Digest - VS Code Extension

Generate Gitingest-style prompt-friendly digests of your local codebase.

## Features

- **Local Processing**: No network calls, everything runs locally
- **Sidebar UI**: Easy-to-use interface in VS Code sidebar
- **Flexible Filtering**: Choose between curated mode (common code files) or all text files
- **Gitignore Support**: Respects .gitignore and .gitingestignore files
- **Binary Handling**: Skip or include binary files with base64 encoding
- **Custom Patterns**: Add your own include/exclude glob patterns
- **Markdown Support**: Optional code fences for .md output files

## Usage

1. Open a workspace folder in VS Code
2. Look for "Code Digest" in the Explorer sidebar
3. Configure your options (or use defaults)
4. Click "Generate Digest"
5. The digest file will be created in your workspace root and opened automatically

## Settings

All settings can be configured through the sidebar UI or VS Code settings:

- `codeDigest.outputFileName`: Output file name (default: "digest.txt")
- `codeDigest.mode`: "curated" or "allText" (default: "curated")
- `codeDigest.respectGitignore`: Honor .gitignore files (default: true)
- `codeDigest.includeDotfiles`: Include dotfiles and config files (default: true)
- `codeDigest.includeGitDir`: Include .git directory (default: false)
- `codeDigest.maxFileSizeKB`: Max file size in KB (default: 10240)
- `codeDigest.includeBinary`: Include binary files (default: false)
- `codeDigest.additionalIncludeGlobs`: Extra patterns to include
- `codeDigest.additionalExcludeGlobs`: Extra patterns to exclude
- `codeDigest.markdownCodeFences`: Use code fences in .md files (default: false)

## Output Format

The generated digest follows the Gitingest format:

1. **Summary**: Directory name, file count, timestamp, token estimate
2. **Directory Structure**: Tree view of included files/directories
3. **File Contents**: Each file with clear separators and headers

## Modes

### Curated Mode (Default)
Includes common source code and configuration files:
- Source code: .py, .js, .ts, .java, .cpp, .go, .rs, .swift, etc.
- Config files: package.json, pyproject.toml, .gitignore, .env, etc.
- Documentation: README, LICENSE, CHANGELOG files

### All Text Mode
Includes any file that appears to be text-based using content heuristics.

## Commands

- **Code Digest: Create Digest** (`codeDigest.create`): Generate a digest file

## Requirements

- VS Code 1.85.0 or higher
- Node.js 18+ (for development)

## Known Limitations

- Single workspace folder support (multi-root workspaces prompt for selection)
- Symlinks are not followed, only noted as symlinks
- Token estimation is a simple heuristic, not as accurate as tiktoken
- Very large repositories may take some time to process

## Security & Privacy

- All processing happens locally
- No network calls or external services
- Respects .gitignore by default to avoid including secrets
- Warns when including .git directory or binary files

## Development



================================================
FILE: src/extension.ts
================================================
import * as vscode from 'vscode';
import { SidebarProvider } from './panels/SidebarProvider';
import { DigestGenerator } from './utils/DigestGenerator';

export function activate(context: vscode.ExtensionContext) {
    const sidebarProvider = new SidebarProvider(context.extensionUri);
    const digestGenerator = new DigestGenerator();

    // Register sidebar view
    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider('codeDigest.view', sidebarProvider)
    );

    // Register command
    const generateCommand = vscode.commands.registerCommand('codeDigest.create', async () => {
        await digestGenerator.generateDigest();
    });

    context.subscriptions.push(generateCommand);

    // Listen for messages from sidebar
    sidebarProvider.onDidReceiveMessage(async (message: any) => {
        switch (message.command) {
            case 'generate':
                await digestGenerator.generateDigest();
                break;
            case 'updateSetting':
                await vscode.workspace.getConfiguration('codeDigest').update(
                    message.key,
                    message.value,
                    vscode.ConfigurationTarget.Workspace
                );
                break;
        }
    });
}

export function deactivate() {}


================================================
FILE: src/panels/SidebarProvider.ts
================================================
import * as vscode from 'vscode';

export class SidebarProvider implements vscode.WebviewViewProvider {
    private _view?: vscode.WebviewView;
    private _extensionUri: vscode.Uri;
    private _onDidReceiveMessage = new vscode.EventEmitter<any>();

    public readonly onDidReceiveMessage = this._onDidReceiveMessage.event;

    constructor(extensionUri: vscode.Uri) {
        this._extensionUri = extensionUri;
    }

    resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken
    ): void {
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [
                vscode.Uri.joinPath(this._extensionUri, 'src', 'webview')
            ]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        webviewView.webview.onDidReceiveMessage(
            (message: any) => {
                this._onDidReceiveMessage.fire(message);
            },
            undefined,
        );

        // Send current settings to webview
        this._updateWebviewSettings();

        // Listen for configuration changes
        vscode.workspace.onDidChangeConfiguration((e: any) => {
            if (e.affectsConfiguration('codeDigest')) {
                this._updateWebviewSettings();
            }
        });
    }

    public postMessage(message: any) {
        if (this._view) {
            this._view.webview.postMessage(message);
        }
    }

    private _updateWebviewSettings() {
        const config = vscode.workspace.getConfiguration('codeDigest');
        this.postMessage({
            command: 'updateSettings',
            settings: {
                outputFileName: config.get('outputFileName'),
                mode: config.get('mode'),
                respectGitignore: config.get('respectGitignore'),
                includeDotfiles: config.get('includeDotfiles'),
                includeGitDir: config.get('includeGitDir'),
                maxFileSizeKB: config.get('maxFileSizeKB'),
                includeBinary: config.get('includeBinary'),
                additionalIncludeGlobs: config.get('additionalIncludeGlobs'),
                additionalExcludeGlobs: config.get('additionalExcludeGlobs'),
                markdownCodeFences: config.get('markdownCodeFences')
            }
        });
    }

    private _getHtmlForWebview(webview: vscode.Webview): string {
        const scriptUri = webview.asWebviewUri(
            vscode.Uri.joinPath(this._extensionUri, 'src', 'webview', 'main.js')
        );
        const styleUri = webview.asWebviewUri(
            vscode.Uri.joinPath(this._extensionUri, 'src', 'webview', 'styles.css')
        );
        return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="${styleUri}" rel="stylesheet">
<title>Code Digest</title>
</head>
<body>
<div class="container">
<h2>Create Code Digest</h2>
<p class="subtitle">Gitingest-style local digest</p>
<form id="digestForm">
<div class="form-group">
<label for="outputFileName">Output File:</label>
<input type="text" id="outputFileName" placeholder="digest.txt">
</div>
<div class="form-group">
<label for="mode">Mode:</label>
<select id="mode">
<option value="curated">Curated (common code files)</option>
<option value="allText">All text-like files</option>
</select>
</div>
<div class="form-group">
<label><input type="checkbox" id="respectGitignore"> Respect .gitignore</label>
</div>
<div class="form-group">
<label><input type="checkbox" id="includeDotfiles"> Include dotfiles</label>
</div>
<div class="form-group">
<label><input type="checkbox" id="includeGitDir"> Include .git directory</label>
<small class="warning">⚠️ May include sensitive data and large files</small>
</div>
<div class="form-group">
<label for="maxFileSizeKB">Max file size (KB):</label>
<input type="number" id="maxFileSizeKB" min="1" max="102400">
</div>
<div class="form-group">
<label><input type="checkbox" id="includeBinary"> Include binary files</label>
<small class="warning">⚠️ May produce very large output</small>
</div>
<div class="form-group">
<label for="additionalIncludeGlobs">Additional include patterns:</label>
<textarea id="additionalIncludeGlobs" placeholder="*.config&#10;**/*.yml" rows="2"></textarea>
<small>One glob pattern per line</small>
</div>
<div class="form-group">
<label for="additionalExcludeGlobs">Additional exclude patterns:</label>
<textarea id="additionalExcludeGlobs" placeholder="*.temp&#10;cache/**" rows="2"></textarea>
<small>One glob pattern per line</small>
</div>
<div class="form-group">
<label><input type="checkbox" id="markdownCodeFences"> Use markdown code fences</label>
<small>Only applies to .md output files</small>
</div>
<button type="button" id="generateBtn" class="generate-btn">Generate Digest</button>
</form>
<div id="progress" class="progress hidden">
<div class="spinner"></div>
<span id="progressText">Generating digest...</span>
</div>
<div id="results" class="results hidden">
<h3>Results</h3>
<div id="result"></div>
</div>
</div>
<script src="${scriptUri}"></script>
</body>
</html>`;
    }
}

================================================
FILE: src/utils/binary.ts
================================================
export class BinaryDetector {
    isBinary(buffer: Buffer): boolean {
        // Check first 1KB for binary indicators
        const sampleSize = Math.min(1024, buffer.length);
        const sample = buffer.subarray(0, sampleSize);

        // Check for null bytes
        if (sample.includes(0)) {
            return true;
        }

        // Check for high ratio of control characters
        let controlChars = 0;
        for (let i = 0; i < sample.length; i++) {
            const byte = sample[i];
            // Control characters (excluding common whitespace: \t, \n, \r)
            if ((byte < 32 && byte !== 9 && byte !== 10 && byte !== 13) || byte === 127) {
                controlChars++;
            }
        }

        const controlRatio = controlChars / sample.length;
        return controlRatio > 0.3; // More than 30% control chars = binary
    }
}


================================================
FILE: src/utils/DigestGenerator.ts
================================================
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
import { IgnoreFilter } from './ignore';
import { TreeBuilder } from './tree';
import { BinaryDetector } from './binary';
import { TokenEstimator } from './tokens';
import { minimatch } from 'minimatch';

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);
const lstat = promisify(fs.lstat);
const readlink = promisify(fs.readlink);

interface FileEntry {
    relativePath: string;
    fullPath: string;
    isSymlink: boolean;
    symlinkTarget?: string;
}

export class DigestGenerator {
    private config: vscode.WorkspaceConfiguration;
    private workspaceRoot: string;
    private ignoreFilter: IgnoreFilter;
    private treeBuilder: TreeBuilder;
    private binaryDetector: BinaryDetector;
    private tokenEstimator: TokenEstimator;

    constructor() {
        this.config = vscode.workspace.getConfiguration('codeDigest');
        this.workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';
        this.ignoreFilter = new IgnoreFilter();
        this.treeBuilder = new TreeBuilder();
        this.binaryDetector = new BinaryDetector();
        this.tokenEstimator = new TokenEstimator();
    }

    async generateDigest(): Promise<void> {
        if (!this.workspaceRoot) {
            vscode.window.showErrorMessage('Please open a workspace folder first.');
            return;
        }

        try {
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: "Generating Code Digest",
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: "Scanning files..." });

                // Refresh config
                this.config = vscode.workspace.getConfiguration('codeDigest');

                // Initialize ignore filter
                if (this.config.get<boolean>('respectGitignore')) {
                    await this.ignoreFilter.initialize(this.workspaceRoot);
                }

                progress.report({ increment: 20, message: "Collecting files..." });

                // Collect files
                const files = await this.collectFiles();

                progress.report({ increment: 40, message: "Processing content..." });

                // Generate content
                const { summary, tree, content } = await this.processFiles(files);

                progress.report({ increment: 80, message: "Writing digest file..." });

                // Write output
                const outputPath = await this.writeDigest(summary, tree, content);

                progress.report({ increment: 100, message: "Complete!" });

                // Open the file
                const doc = await vscode.workspace.openTextDocument(outputPath);
                await vscode.window.showTextDocument(doc);

                vscode.window.showInformationMessage(
                    `Code digest generated: ${path.basename(outputPath)}`
                );
            });

        } catch (error) {
            const message = error instanceof Error ? error.message : 'Unknown error occurred';
            vscode.window.showErrorMessage(`Failed to generate digest: ${message}`);
        }
    }

    private async collectFiles(): Promise<FileEntry[]> {
        const files: FileEntry[] = [];
        const mode = this.config.get<string>('mode', 'curated');

        await this.traverseDirectory(this.workspaceRoot, '', files, mode);

        // Sort files by path
        files.sort((a, b) => a.relativePath.localeCompare(b.relativePath));

        return files;
    }

    private async traverseDirectory(
        fullPath: string,
        relativePath: string,
        files: FileEntry[],
        mode: string
    ): Promise<void> {
        try {
            const entries = await readdir(fullPath);

            for (const entry of entries) {
                const entryFullPath = path.join(fullPath, entry);
                const entryRelativePath = path.join(relativePath, entry).replace(/\\/g, '/');

                // Check if should skip
                if (this.shouldSkipEntry(entry, entryRelativePath, entryFullPath)) {
                    continue;
                }

                try {
                    const stats = await lstat(entryFullPath);

                    if (stats.isSymbolicLink()) {
                        let symlinkTarget: string | undefined;
                        try {
                            symlinkTarget = await readlink(entryFullPath);
                        } catch {
                            symlinkTarget = '<broken link>';
                        }

                        files.push({
                            relativePath: entryRelativePath,
                            fullPath: entryFullPath,
                            isSymlink: true,
                            symlinkTarget
                        });
                    } else if (stats.isDirectory()) {
                        await this.traverseDirectory(entryFullPath, entryRelativePath, files, mode);
                    } else if (stats.isFile()) {
                        if (this.shouldIncludeFile(entry, entryRelativePath, stats.size, mode)) {
                            files.push({
                                relativePath: entryRelativePath,
                                fullPath: entryFullPath,
                                isSymlink: false
                            });
                        }
                    }
                } catch (error) {
                    // Skip files we can't stat
                    console.warn(`Could not stat ${entryFullPath}:`, error);
                }
            }
        } catch (error) {
            console.warn(`Could not read directory ${fullPath}:`, error);
        }
    }

    private shouldSkipEntry(name: string, relativePath: string, fullPath: string): boolean {
        // Check .git directory
        if (name === '.git') {
            return !this.config.get<boolean>('includeGitDir');
        }

        // Check dotfiles
        if (name.startsWith('.') && !this.config.get<boolean>('includeDotfiles')) {
            return true;
        }

        // Check ignore patterns
        if (this.config.get<boolean>('respectGitignore')) {
            if (this.ignoreFilter.shouldIgnore(relativePath)) {
                return true;
            }
        }

        // Check additional exclude globs
        const excludeGlobs = this.config.get<string[]>('additionalExcludeGlobs', []);
        for (const glob of excludeGlobs) {
            if (minimatch(relativePath, glob)) {
                // Check if force-included
                const includeGlobs = this.config.get<string[]>('additionalIncludeGlobs', []);
                const forceIncluded = includeGlobs.some(includeGlob => 
                    minimatch(relativePath, includeGlob)
                );
                if (!forceIncluded) {
                    return true;
                }
            }
        }

        return false;
    }

    private shouldIncludeFile(name: string, relativePath: string, size: number, mode: string): boolean {
        // Check file size
        const maxSizeBytes = (this.config.get<number>('maxFileSizeKB', 10240) * 1024);
        if (size > maxSizeBytes) {
            return false;
        }

        // Check additional include globs (force include)
        const includeGlobs = this.config.get<string[]>('additionalIncludeGlobs', []);
        if (includeGlobs.some(glob => minimatch(relativePath, glob))) {
            return true;
        }

        if (mode === 'curated') {
            return this.isCuratedFile(name, relativePath);
        } else if (mode === 'allText') {
            // For allText mode, we'll need to check if it's text-like
            // This is a heuristic - in practice you might want to read a small chunk
            return this.looksLikeTextFile(name);
        }

        return false;
    }

    private isCuratedFile(name: string, relativePath: string): boolean {
        const ext = path.extname(name).toLowerCase();
        const basename = path.basename(name);

        // Code file extensions
        const codeExtensions = [
            '.py', '.java', '.js', '.jsx', '.ts', '.tsx', '.c', '.h', '.cpp', '.cc', 
            '.cxx', '.hpp', '.hh', '.cs', '.swift', '.php', '.sql', '.rb', '.go', 
            '.kt', '.r', '.dart', '.rs', '.vue', '.svelte'
        ];

        if (codeExtensions.includes(ext)) {
            return true;
        }

        // Config and documentation files by name
        const configNames = [
            'package.json', 'pyproject.toml', 'go.mod', 'cargo.toml', 'gemfile',
            'requirements.txt', 'pipfile', 'makefile', 'dockerfile', 'procfile',
            '.gitignore', '.gitingestignore', '.gitkeep', '.editorconfig', 
            '.prettierrc', '.eslintrc', '.npmrc', '.yarnrc', '.python-version'
        ];

        const lowerName = basename.toLowerCase();
        if (configNames.some(config => lowerName.includes(config.replace('.', '')))) {
            return true;
        }

        // README, LICENSE, CHANGELOG files
        if (lowerName.startsWith('readme') || 
            lowerName.startsWith('license') || 
            lowerName.startsWith('changelog') ||
            lowerName.includes('license') ||
            lowerName === 'notice') {
            return true;
        }

        // Environment files
        if (lowerName.startsWith('.env')) {
            return true;
        }

        return false;
    }

    private looksLikeTextFile(name: string): boolean {
        const ext = path.extname(name).toLowerCase();
        
        // Known text extensions
        const textExtensions = [
            '.txt', '.md', '.rst', '.json', '.xml', '.yml', '.yaml', '.toml', 
            '.ini', '.cfg', '.conf', '.log', '.csv', '.tsv', '.html', '.htm', 
            '.css', '.scss', '.sass', '.less', '.svg'
        ];

        if (textExtensions.includes(ext)) {
            return true;
        }

        // Binary extensions to exclude
        const binaryExtensions = [
            '.exe', '.dll', '.so', '.dylib', '.bin', '.obj', '.o', '.a', '.lib',
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.svg', '.webp',
            '.mp3', '.mp4', '.avi', '.mov', '.wav', '.flac', '.ogg',
            '.zip', '.tar', '.gz', '.bz2', '.7z', '.rar', '.jar', '.war',
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx'
        ];

        if (binaryExtensions.includes(ext)) {
            return false;
        }

        // No extension or unknown extension - might be text
        return true;
    }

    private async processFiles(files: FileEntry[]): Promise<{
        summary: string;
        tree: string;
        content: string;
    }> {
        const rootName = path.basename(this.workspaceRoot);
        const timestamp = new Date().toISOString();
        
        // Build tree
        const tree = this.treeBuilder.buildTree(files, rootName);
        
        // Process file contents
        const contentBlocks: string[] = [];
        let processedCount = 0;

        for (const file of files) {
            const block = await this.processFileContent(file);
            if (block) {
                contentBlocks.push(block);
                processedCount++;
            }
        }

        const content = contentBlocks.join('\n');
        const fullText = tree + '\n' + content;
        const tokenEstimate = this.tokenEstimator.estimate(fullText);

        const summary = [
            `Directory: ${rootName}`,
            `Files analyzed: ${processedCount}`,
            `Generated: ${timestamp}`,
            `Estimated tokens: ${tokenEstimate}`
        ].join('\n');

        return { summary, tree, content };
    }

    private async processFileContent(file: FileEntry): Promise<string> {
        const separator = '='.repeat(48);
        
        try {
            if (file.isSymlink) {
                return [
                    separator,
                    `SYMLINK: ${file.relativePath} -> ${file.symlinkTarget}`,
                    separator,
                    '',
                    ''
                ].join('\n');
            }

            // Read file
            const buffer = await readFile(file.fullPath);
            
            // Check if binary
            const isBinary = this.binaryDetector.isBinary(buffer);
            const includeBinary = this.config.get<boolean>('includeBinary', false);
            
            let contentText: string;
            
            if (isBinary && !includeBinary) {
                contentText = '[Binary file]';
            } else if (isBinary && includeBinary) {
                try {
                    contentText = buffer.toString('utf8');
                } catch {
                    contentText = `Content (base64):\n${buffer.toString('base64')}`;
                }
            } else {
                contentText = buffer.toString('utf8');
            }

            // Apply markdown code fences if enabled and output is .md
            const outputFileName = this.config.get<string>('outputFileName', 'digest.txt');
            const useCodeFences = this.config.get<boolean>('markdownCodeFences', false) && 
                                 outputFileName.toLowerCase().endsWith('.md');
            
            if (useCodeFences && !isBinary) {
                const ext = path.extname(file.relativePath).slice(1);
                const language = this.getLanguageForExtension(ext);
                contentText = `\`\`\`${language}\n${contentText}\n\`\`\``;
            }

            return [
                separator,
                `FILE: ${file.relativePath}`,
                separator,
                contentText,
                ''
            ].join('\n');

        } catch (error) {
            return [
                separator,
                `FILE: ${file.relativePath}`,
                separator,
                `Error reading file: ${error instanceof Error ? error.message : 'Unknown error'}`,
                ''
            ].join('\n');
        }
    }

    private getLanguageForExtension(ext: string): string {
        const langMap: Record<string, string> = {
            'js': 'javascript',
            'jsx': 'javascript',
            'ts': 'typescript',
            'tsx': 'typescript',
            'py': 'python',
            'java': 'java',
            'c': 'c',
            'cpp': 'cpp',
            'cc': 'cpp',
            'cxx': 'cpp',
            'cs': 'csharp',
            'php': 'php',
            'rb': 'ruby',
            'go': 'go',
            'rs': 'rust',
            'swift': 'swift',
            'kt': 'kotlin',
            'dart': 'dart',
            'json': 'json',
            'xml': 'xml',
            'html': 'html',
            'css': 'css',
            'scss': 'scss',
            'yml': 'yaml',
            'yaml': 'yaml',
            'md': 'markdown',
            'sh': 'bash',
            'sql': 'sql'
        };
        
        return langMap[ext.toLowerCase()] || '';
    }

    private async writeDigest(summary: string, tree: string, content: string): Promise<string> {
        const outputFileName = this.config.get<string>('outputFileName', 'digest.txt');
        const outputPath = path.join(this.workspaceRoot, outputFileName);
        
        const fullContent = [
            summary,
            '',
            tree,
            '',
            content
        ].join('\n');

        await writeFile(outputPath, fullContent, 'utf8');
        
        return outputPath;
    }
}


================================================
FILE: src/utils/ignore.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import ignore, { Ignore } from 'ignore';

export class IgnoreFilter {
    private ignoreInstance: Ignore;
    private defaultIgnores: string[] = [
        'node_modules/**',
        'dist/**',
        'build/**',
        'target/**',
        'out/**',
        '.next/**',
        '.nuxt/**',
        '.venv/**',
        'venv/**',
        '.idea/**',
        '.vscode/**',
        '__pycache__/**',
        '.pytest_cache/**',
        'coverage/**',
        'logs/**',
        '*.log',
        'site-packages/**',
        '.DS_Store',
        'Thumbs.db'
    ];

    constructor() {
        this.ignoreInstance = ignore();
    }

    async initialize(rootPath: string): Promise<void> {
        // Add default ignores
        this.ignoreInstance.add(this.defaultIgnores);

        // Load .gitignore files
        await this.loadIgnoreFiles(rootPath, '.gitignore');
        await this.loadIgnoreFiles(rootPath, '.gitingestignore');
    }

    private async loadIgnoreFiles(rootPath: string, filename: string): Promise<void> {
        try {
            await this.walkDirectory(rootPath, async (dirPath) => {
                const ignoreFilePath = path.join(dirPath, filename);
                try {
                    const content = await fs.promises.readFile(ignoreFilePath, 'utf8');
                    const relativeDirPath = path.relative(rootPath, dirPath);
                    const patterns = content
                        .split('\n')
                        .map((line: string) => line.trim())
                        .filter((line: string) => line && !line.startsWith('#'))
                        .map((pattern: string) => {
                            if (relativeDirPath && !pattern.startsWith('/')) {
                                return path.join(relativeDirPath, pattern).replace(/\\/g, '/');
                            }
                            return pattern.startsWith('/') ? pattern.slice(1) : pattern;
                        });
                    
                    this.ignoreInstance.add(patterns);
                } catch {
                    // Ignore files that can't be read
                }
            });
        } catch {
            // Ignore directory traversal errors
        }
    }

    private async walkDirectory(dirPath: string, callback: (dir: string) => Promise<void>): Promise<void> {
        await callback(dirPath);
        
        try {
            const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });
            
            for (const entry of entries) {
                if (entry.isDirectory() && entry.name !== '.git') {
                    const subDirPath = path.join(dirPath, entry.name);
                    await this.walkDirectory(subDirPath, callback);
                }
            }
        } catch {
            // Ignore directories we can't read
        }
    }

    shouldIgnore(relativePath: string): boolean {
        return this.ignoreInstance.ignores(relativePath);
    }
}


================================================
FILE: src/utils/tokens.ts
================================================
export class TokenEstimator {
    estimate(text: string): string {
        // Simple heuristic: tokens ≈ words * 1.3
        const words = text.split(/\s+/).filter(word => word.length > 0).length;
        const tokens = Math.floor(words * 1.3);
        
        return this.humanizeNumber(tokens);
    }

    private humanizeNumber(num: number): string {
        if (num >= 1_000_000) {
            return `${(num / 1_000_000).toFixed(1)}M`;
        } else if (num >= 1_000) {
            return `${(num / 1_000).toFixed(1)}k`;
        } else {
            return num.toString();
        }
    }
}


================================================
FILE: src/utils/tree.ts
================================================
import * as path from 'path';

interface FileEntry {
    relativePath: string;
    fullPath: string;
    isSymlink: boolean;
    symlinkTarget?: string;
}

export class TreeBuilder {
    buildTree(files: FileEntry[], rootName: string): string {
        const tree = this.buildTreeStructure(files, rootName);
        return `Directory structure:\n${this.renderTree(tree)}`;
    }

    private buildTreeStructure(files: FileEntry[], rootName: string): TreeNode {
        const root: TreeNode = {
            name: rootName,
            isDirectory: true,
            children: new Map()
        };

        for (const file of files) {
            this.addToTree(root, file.relativePath, file.isSymlink);
        }

        return root;
    }

    private addToTree(root: TreeNode, relativePath: string, isSymlink: boolean): void {
        const parts = relativePath.split('/').filter(part => part);
        let current = root;

        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            const isLastPart = i === parts.length - 1;
            
            if (!current.children.has(part)) {
                current.children.set(part, {
                    name: part,
                    isDirectory: !isLastPart,
                    isSymlink: isLastPart ? isSymlink : false,
                    children: new Map()
                });
            }
            
            current = current.children.get(part)!;
        }
    }

    private renderTree(node: TreeNode, prefix: string = '', isLast: boolean = true): string {
        const lines: string[] = [];
        
        // Render current node
        const connector = isLast ? '└── ' : '├── ';
        const displayName = node.isDirectory ? `${node.name}/` : node.name;
        const symlinkIndicator = node.isSymlink ? ' -> <target>' : '';
        
        lines.push(`${prefix}${connector}${displayName}${symlinkIndicator}`);

        // Render children
        const children = Array.from(node.children.values()).sort((a, b) => {
            // Directories first, then files
            if (a.isDirectory && !b.isDirectory) return -1;
            if (!a.isDirectory && b.isDirectory) return 1;
            return a.name.localeCompare(b.name);
        });

        children.forEach((child, index) => {
            const isLastChild = index === children.length - 1;
            const childPrefix = prefix + (isLast ? '    ' : '│   ');
            lines.push(this.renderTree(child, childPrefix, isLastChild));
        });

        return lines.join('\n');
    }
}

interface TreeNode {
    name: string;
    isDirectory: boolean;
    isSymlink?: boolean;
    children: Map<string, TreeNode>;
}


================================================
FILE: src/webview/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Digest</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h2>Create Code Digest</h2>
        <p class="subtitle">Gitingest-style local digest</p>
        
        <form id="digestForm">
            <div class="form-group">
                <label for="outputFileName">Output File:</label>
                <input type="text" id="outputFileName" placeholder="digest.txt">
            </div>

            <div class="form-group">
                <label for="mode">Mode:</label>
                <select id="mode">
                    <option value="curated">Curated (common code files)</option>
                    <option value="allText">All text-like files</option>
                </select>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="respectGitignore"> Respect .gitignore
                </label>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="includeDotfiles"> Include dotfiles
                </label>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="includeGitDir"> Include .git directory
                </label>
                <small class="warning">⚠️ May include sensitive data and large files</small>
            </div>

            <div class="form-group">
                <label for="maxFileSizeKB">Max file size (KB):</label>
                <input type="number" id="maxFileSizeKB" min="1" max="102400">
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="includeBinary"> Include binary files
                </label>
                <small class="warning">⚠️ May produce very large output</small>
            </div>

            <div class="form-group">
                <label for="additionalIncludeGlobs">Additional include patterns:</label>
                <textarea id="additionalIncludeGlobs" placeholder="*.config&#10;**/*.yml" rows="2"></textarea>
                <small>One glob pattern per line</small>
            </div>

            <div class="form-group">
                <label for="additionalExcludeGlobs">Additional exclude patterns:</label>
                <textarea id="additionalExcludeGlobs" placeholder="*.temp&#10;cache/**" rows="2"></textarea>
                <small>One glob pattern per line</small>
            </div>

            <div class="form-group">
                <label>
                    <input type="checkbox" id="markdownCodeFences"> Use markdown code fences
                </label>
                <small>Only applies to .md output files</small>
            </div>

            <button type="button" id="generateBtn" class="generate-btn">
                Generate Digest
            </button>
        </form>

        <div id="progress" class="progress hidden">
            <div class="spinner"></div>
            <span id="progressText">Generating digest...</span>
        </div>

        <div id="results" class="results hidden">
            <h3>Results</h3>
            <div id="resultsContent"></div>
            <button type="button" id="openFileBtn" class="open-btn">Open Digest File</button>
        </div>
    </div>
    
    <script src="main.js"></script>
</body>
</html>


================================================
FILE: src/webview/main.js
================================================
(function() {
    const vscode = acquireVsCodeApi();
    let currentSettings = {};

    // Get DOM elements
    const form = document.getElementById('digestForm');
    const generateBtn = document.getElementById('generateBtn');
    const progress = document.getElementById('progress');
    const results = document.getElementById('results');
    const openFileBtn = document.getElementById('openFileBtn');

    // Form elements
    const outputFileName = document.getElementById('outputFileName');
    const mode = document.getElementById('mode');
    const respectGitignore = document.getElementById('respectGitignore');
    const includeDotfiles = document.getElementById('includeDotfiles');
    const includeGitDir = document.getElementById('includeGitDir');
    const maxFileSizeKB = document.getElementById('maxFileSizeKB');
    const includeBinary = document.getElementById('includeBinary');
    const additionalIncludeGlobs = document.getElementById('additionalIncludeGlobs');
    const additionalExcludeGlobs = document.getElementById('additionalExcludeGlobs');
    const markdownCodeFences = document.getElementById('markdownCodeFences');

    // Listen for messages from extension
    window.addEventListener('message', event => {
        const message = event.data;
        switch (message.command) {
            case 'updateSettings':
                currentSettings = message.settings;
                updateFormFromSettings();
                break;
            case 'progress':
                updateProgress(message.text);
                break;
            case 'complete':
                showResults(message);
                break;
            case 'error':
                showError(message.error);
                break;
        }
    });

    function updateFormFromSettings() {
        outputFileName.value = currentSettings.outputFileName || 'digest.txt';
        mode.value = currentSettings.mode || 'curated';
        respectGitignore.checked = currentSettings.respectGitignore !== false;
        includeDotfiles.checked = currentSettings.includeDotfiles !== false;
        includeGitDir.checked = currentSettings.includeGitDir === true;
        maxFileSizeKB.value = currentSettings.maxFileSizeKB || 10240;
        includeBinary.checked = currentSettings.includeBinary === true;
        additionalIncludeGlobs.value = (currentSettings.additionalIncludeGlobs || []).join('\n');
        additionalExcludeGlobs.value = (currentSettings.additionalExcludeGlobs || []).join('\n');
        markdownCodeFences.checked = currentSettings.markdownCodeFences === true;
    }

    function updateSetting(key, value) {
        vscode.postMessage({
            command: 'updateSetting',
            key: key,
            value: value
        });
    }

    // Add event listeners for form changes
    outputFileName.addEventListener('change', () => updateSetting('outputFileName', outputFileName.value));
    mode.addEventListener('change', () => updateSetting('mode', mode.value));
    respectGitignore.addEventListener('change', () => updateSetting('respectGitignore', respectGitignore.checked));
    includeDotfiles.addEventListener('change', () => updateSetting('includeDotfiles', includeDotfiles.checked));
    includeGitDir.addEventListener('change', () => updateSetting('includeGitDir', includeGitDir.checked));
    maxFileSizeKB.addEventListener('change', () => updateSetting('maxFileSizeKB', parseInt(maxFileSizeKB.value)));
    includeBinary.addEventListener('change', () => updateSetting('includeBinary', includeBinary.checked));
    markdownCodeFences.addEventListener('change', () => updateSetting('markdownCodeFences', markdownCodeFences.checked));

    additionalIncludeGlobs.addEventListener('change', () => {
        const globs = additionalIncludeGlobs.value.split('\n').filter(line => line.trim());
        updateSetting('additionalIncludeGlobs', globs);
    });

    additionalExcludeGlobs.addEventListener('change', () => {
        const globs = additionalExcludeGlobs.value.split('\n').filter(line => line.trim());
        updateSetting('additionalExcludeGlobs', globs);
    });

    // Generate button handler
    generateBtn.addEventListener('click', () => {
        showProgress();
        vscode.postMessage({
            command: 'generate'
        });
    });

    // Open file button handler
    openFileBtn.addEventListener('click', () => {
        vscode.postMessage({
            command: 'openFile'
        });
    });

    function showProgress() {
        progress.classList.remove('hidden');
        results.classList.add('hidden');
        generateBtn.disabled = true;
    }

    function updateProgress(text) {
        document.getElementById('progressText').textContent = text;
    }

    function showResults(data) {
        progress.classList.add('hidden');
        results.classList.remove('hidden');
        generateBtn.disabled = false;
        
        document.getElementById('resultsContent').innerHTML = `
            <p><strong>Files analyzed:</strong> ${data.fileCount}</p>
            <p><strong>Generated:</strong> ${data.outputPath}</p>
            <p><strong>Estimated tokens:</strong> ${data.tokenEstimate}</p>
        `;
    }

    function showError(error) {
        progress.classList.add('hidden');
        results.classList.remove('hidden');
        generateBtn.disabled = false;
        
        document.getElementById('resultsContent').innerHTML = `
            <div class="error">
                <strong>Error:</strong> ${error}
            </div>
        `;
    }
})();


================================================
FILE: src/webview/styles.css
================================================
body {
    padding: 10px;
    color: var(--vscode-foreground);
    background-color: var(--vscode-editor-background);
    font-family: var(--vscode-font-family);
    font-size: var(--vscode-font-size);
}

.container {
    max-width: 100%;
}

h2 {
    margin-top: 0;
    color: var(--vscode-titleBar-activeForeground);
}

.subtitle {
    color: var(--vscode-descriptionForeground);
    font-size: 0.9em;
    margin-bottom: 20px;
}

.form-group {
    margin-bottom: 15px;
}

label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
}

input[type="text"],
input[type="number"],
select,
textarea {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid var(--vscode-input-border);
    background-color: var(--vscode-input-background);
    color: var(--vscode-input-foreground);
    border-radius: 2px;
    box-sizing: border-box;
}

input[type="text"]:focus,
input[type="number"]:focus,
select:focus,
textarea:focus {
    outline: 1px solid var(--vscode-focusBorder);
    border-color: var(--vscode-focusBorder);
}

input[type="checkbox"] {
    margin-right: 8px;
}

textarea {
    resize: vertical;
    font-family: var(--vscode-editor-font-family);
    font-size: 0.9em;
}

.generate-btn,
.open-btn {
    background-color: var(--vscode-button-background);
    color: var(--vscode-button-foreground);
    border: none;
    padding: 8px 16px;
    border-radius: 2px;
    cursor: pointer;
    font-size: 0.9em;
    width: 100%;
}

.generate-btn:hover,
.open-btn:hover {
    background-color: var(--vscode-button-hoverBackground);
}

.generate-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.progress {
    text-align: center;
    padding: 20px;
}

.spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid var(--vscode-progressBar-background);
    border-radius: 50%;
    border-top-color: var(--vscode-progressBar-background);
    animation: spin 1s ease-in-out infinite;
    margin-right: 10px;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.results {
    background-color: var(--vscode-editor-background);
    border: 1px solid var(--vscode-panel-border);
    border-radius: 3px;
    padding: 15px;
    margin-top: 15px;
}

.results h3 {
    margin-top: 0;
    color: var(--vscode-titleBar-activeForeground);
}

.error {
    color: var(--vscode-errorForeground);
    background-color: var(--vscode-inputValidation-errorBackground);
    border: 1px solid var(--vscode-inputValidation-errorBorder);
    padding: 10px;
    border-radius: 3px;
}

.warning {
    color: var(--vscode-editorWarning-foreground);
    font-size: 0.8em;
    display: block;
    margin-top: 3px;
}

.hidden {
    display: none;
}

small {
    color: var(--vscode-descriptionForeground);
    font-size: 0.8em;
    display: block;
    margin-top: 3px;
}


================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2020",
    "outDir": "out",
    "lib": ["ES2020"],
    "sourceMap": true,
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "exclude": ["node_modules", ".vscode-test"]
}

