Directory: Code Digest
Files analyzed: 9
Generated: 2025-08-12T13:25:20.207Z
Estimated tokens: 5.1k

Directory structure:
‚îî‚îÄ‚îÄ Code Digest/
    ‚îú‚îÄ‚îÄ src/
    ‚îÇ   ‚îú‚îÄ‚îÄ panels/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SidebarProvider.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ utils/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ binary.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DigestGenerator.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ignore.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tokens.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tree.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ webview/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.js
    ‚îÇ   ‚îî‚îÄ‚îÄ extension.ts
    ‚îî‚îÄ‚îÄ README.md

================================================
FILE: README.md
================================================
# Code Digest Extension

A VS Code extension for code digest features.

## Structure

```
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ extension.ts
‚îÇ   ‚îú‚îÄ‚îÄ panels/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SidebarProvider.ts
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ignore.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tree.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ binary.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tokens.ts
‚îÇ   ‚îî‚îÄ‚îÄ webview/
‚îÇ       ‚îú‚îÄ‚îÄ index.html
‚îÇ       ‚îú‚îÄ‚îÄ main.js
‚îÇ       ‚îî‚îÄ‚îÄ styles.css
‚îî‚îÄ‚îÄ README.md
```


# Code Digest - VS Code Extension

Generate Gitingest-style prompt-friendly digests of your local codebase.

## Features

- **Local Processing**: No network calls, everything runs locally
- **Sidebar UI**: Easy-to-use interface in VS Code sidebar
- **Flexible Filtering**: Choose between curated mode (common code files) or all text files
- **Gitignore Support**: Respects .gitignore and .gitingestignore files
- **Binary Handling**: Skip or include binary files with base64 encoding
- **Custom Patterns**: Add your own include/exclude glob patterns
- **Markdown Support**: Optional code fences for .md output files

## Usage

1. Open a workspace folder in VS Code
2. Look for "Code Digest" in the Explorer sidebar
3. Configure your options (or use defaults)
4. Click "Generate Digest"
5. The digest file will be created in your workspace root and opened automatically

## Settings

All settings can be configured through the sidebar UI or VS Code settings:

- `codeDigest.outputFileName`: Output file name (default: "digest.txt")
- `codeDigest.mode`: "curated" or "allText" (default: "curated")
- `codeDigest.respectGitignore`: Honor .gitignore files (default: true)
- `codeDigest.includeDotfiles`: Include dotfiles and config files (default: true)
- `codeDigest.includeGitDir`: Include .git directory (default: false)
- `codeDigest.maxFileSizeKB`: Max file size in KB (default: 10240)
- `codeDigest.includeBinary`: Include binary files (default: false)
- `codeDigest.additionalIncludeGlobs`: Extra patterns to include
- `codeDigest.additionalExcludeGlobs`: Extra patterns to exclude
- `codeDigest.markdownCodeFences`: Use code fences in .md files (default: false)

## Output Format

The generated digest follows the Gitingest format:

1. **Summary**: Directory name, file count, timestamp, token estimate
2. **Directory Structure**: Tree view of included files/directories
3. **File Contents**: Each file with clear separators and headers

## Modes

### Curated Mode (Default)
Includes common source code and configuration files:
- Source code: .py, .js, .ts, .java, .cpp, .go, .rs, .swift, etc.
- Config files: package.json, pyproject.toml, .gitignore, .env, etc.
- Documentation: README, LICENSE, CHANGELOG files

### All Text Mode
Includes any file that appears to be text-based using content heuristics.

## Commands

- **Code Digest: Create Digest** (`codeDigest.create`): Generate a digest file

## Requirements

- VS Code 1.85.0 or higher
- Node.js 18+ (for development)

## Known Limitations

- Single workspace folder support (multi-root workspaces prompt for selection)
- Symlinks are not followed, only noted as symlinks
- Token estimation is a simple heuristic, not as accurate as tiktoken
- Very large repositories may take some time to process

## Security & Privacy

- All processing happens locally
- No network calls or external services
- Respects .gitignore by default to avoid including secrets
- Warns when including .git directory or binary files

## Development



================================================
FILE: src/extension.ts
================================================
import * as vscode from 'vscode';
import { SidebarProvider } from './panels/SidebarProvider';
import { DigestGenerator } from './utils/DigestGenerator';

export function activate(context: vscode.ExtensionContext) {
    const sidebarProvider = new SidebarProvider(context.extensionUri);
    const digestGenerator = new DigestGenerator();

    // Register sidebar view
    context.subscriptions.push(
        vscode.window.registerWebviewViewProvider('codeDigest.view', sidebarProvider)
    );

    // Register command
    const generateCommand = vscode.commands.registerCommand('codeDigest.create', async () => {
        await digestGenerator.generateDigest();
    });

    context.subscriptions.push(generateCommand);

    // Listen for messages from sidebar
    sidebarProvider.onDidReceiveMessage(async (message: any) => {
        switch (message.command) {
            case 'generate':
                await digestGenerator.generateDigest();
                // Notify webview to reset UI after digest generation
                sidebarProvider.postMessage({
                    command: 'complete',
                    fileCount: 0, // Optionally pass actual file count, outputPath, tokenEstimate
                    outputPath: '',
                    tokenEstimate: 0
                });
                break;
            case 'updateSetting':
                await vscode.workspace.getConfiguration('codeDigest').update(
                    message.key,
                    message.value,
                    vscode.ConfigurationTarget.Workspace
                );
                break;
            case 'refreshExtension':
                // Re-send settings and refresh sidebar only if _view is defined
                if (sidebarProvider['_view']) {
                    await sidebarProvider['resolveWebviewView'](
                        sidebarProvider['_view'],
                        { state: undefined },
                        {} as vscode.CancellationToken
                    );
                }
                break;
        }
    });
}

export function deactivate() {}


================================================
FILE: src/panels/SidebarProvider.ts
================================================
import * as vscode from 'vscode';

export class SidebarProvider implements vscode.WebviewViewProvider {
    private _view?: vscode.WebviewView;
    private _extensionUri: vscode.Uri;
    private _onDidReceiveMessage = new vscode.EventEmitter<any>();

    public readonly onDidReceiveMessage = this._onDidReceiveMessage.event;

    constructor(extensionUri: vscode.Uri) {
        this._extensionUri = extensionUri;
    }

    resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken
    ): void {
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [
                vscode.Uri.joinPath(this._extensionUri, 'src', 'webview')
            ]
        };

        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);

        webviewView.webview.onDidReceiveMessage(
            (message: any) => {
                this._onDidReceiveMessage.fire(message);
            },
            undefined,
        );

        // Send current settings to webview
        this._updateWebviewSettings();

        // Listen for configuration changes
        vscode.workspace.onDidChangeConfiguration((e: any) => {
            if (e.affectsConfiguration('codeDigest')) {
                this._updateWebviewSettings();
            }
        });
    }

    public postMessage(message: any) {
        if (this._view) {
            this._view.webview.postMessage(message);
        }
    }

    private async _updateWebviewSettings() {
        const config = vscode.workspace.getConfiguration('codeDigest');
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        let tree = '';
        let extensions: string[] = [];
        if (workspaceFolder) {
            try {
                // Use dynamic import for compatibility
                const fg = await import('fast-glob');
                const pathMod = await import('path');
                const { TreeBuilder } = await import('../utils/tree');
                const files: string[] = await fg.default(["**/*.*"], { cwd: workspaceFolder, dot: true, onlyFiles: true });
                const fileEntries = files.map((f: string) => ({ relativePath: f, fullPath: pathMod.join(workspaceFolder, f), isSymlink: false }));
                tree = new TreeBuilder().buildTree(fileEntries, pathMod.basename(workspaceFolder));
                const excludedExtensions = [
                    'png', 'jpg', 'jpeg', 'gif', 'bmp', 'ico', 'webp', 'tiff', 'svg',
                    'mp4', 'avi', 'mov', 'wmv', 'flv', 'mkv', 'webm', 'mpg', 'mpeg', '3gp',
                    'mp3', 'wav', 'flac', 'ogg', 'aac', 'm4a', 'wma',
                    'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'odt', 'ods', 'odp', 'rtf',
                    'zip', 'tar', 'gz', 'bz2', '7z', 'rar', 'jar', 'war',
                    'exe', 'dll', 'so', 'dylib', 'bin', 'obj', 'o', 'a', 'lib'
                ];
                extensions = Array.from(new Set(
                    files.map(f => {
                        const ext = pathMod.extname(f);
                        return ext.startsWith('.') ? ext.slice(1) : '';
                    }).filter(e => e && !excludedExtensions.includes(e))
                ));
                extensions = extensions.sort();
            } catch (err) {
                tree = 'Error building tree';
                extensions = [];
            }
        }
        this.postMessage({
            command: 'updateSettings',
            settings: {
                outputFileName: config.get('outputFileName'),
                respectGitignore: config.get('respectGitignore'),
                includeDotfiles: config.get('includeDotfiles'),
                includeGitDir: config.get('includeGitDir'),
                maxFileSizeKB: config.get('maxFileSizeKB'),
                includeBinary: config.get('includeBinary'),
                additionalIncludeGlobs: config.get('additionalIncludeGlobs'),
                additionalExcludeGlobs: config.get('additionalExcludeGlobs'),
                markdownCodeFences: config.get('markdownCodeFences'),
                tree,
                extensions
            }
        });
    }

    private _getHtmlForWebview(webview: vscode.Webview): string {
        const scriptUri = webview.asWebviewUri(
            vscode.Uri.joinPath(this._extensionUri, 'src', 'webview', 'main.js')
        );
        const styleUri = webview.asWebviewUri(
            vscode.Uri.joinPath(this._extensionUri, 'src', 'webview', 'styles.css')
        );
    return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="${styleUri}" rel="stylesheet">
<title>Code Digest</title>
</head>
<body>
<div class="container">
<h2>Create Code Digest</h2>
<p class="subtitle">Gitingest-style local digest</p>
<form id="digestForm">
<button type="button" id="refreshBtn" class="refresh-btn">üîÑ Refresh Extension</button>
<div class="form-group">
<label for="outputFileName">Output File:</label>
<input type="text" id="outputFileName" placeholder="digest">
<div class="ext-choice">
    <label><input type="checkbox" id="extTxt" checked> .txt</label>
    <label><input type="checkbox" id="extMd"> .md</label>
</div>
</div>
<div class="form-group">
<label>Directory Tree:</label>
<div id="treeBox" class="tree-box"><pre id="treeContent"></pre></div>
</div>
<div class="form-group">
<label>File Extensions to Export:</label>
<div id="extCheckboxes" class="ext-checkboxes"></div>
</div>
<div class="form-group">
<label><input type="checkbox" id="respectGitignore"> Respect .gitignore</label>
</div>
<div class="form-group">
<label><input type="checkbox" id="includeDotfiles"> Include dotfiles</label>
</div>
<div class="form-group">
<label><input type="checkbox" id="includeGitDir"> Include .git directory</label>
<small class="warning">‚ö†Ô∏è May include sensitive data and large files</small>
</div>
<div class="form-group">
<label for="maxFileSizeKB">Max file size (KB):</label>
<input type="number" id="maxFileSizeKB" min="1" max="102400">
</div>
<div class="form-group">
<label><input type="checkbox" id="includeBinary"> Include binary files</label>
<small class="warning">‚ö†Ô∏è May produce very large output</small>
</div>
<div class="form-group">
<label for="additionalIncludeGlobs">Additional include patterns:</label>
<textarea id="additionalIncludeGlobs" placeholder="*.config&#10;**/*.yml" rows="2"></textarea>
<small>One glob pattern per line</small>
</div>
<div class="form-group">
<label for="additionalExcludeGlobs">Additional exclude patterns:</label>
<textarea id="additionalExcludeGlobs" placeholder="*.temp&#10;cache/**" rows="2"></textarea>
<small>One glob pattern per line</small>
</div>
<div class="form-group">
<label><input type="checkbox" id="markdownCodeFences"> Use markdown code fences</label>
<small>Only applies to .md output files</small>
</div>
<button type="button" id="generateBtn" class="generate-btn">Generate Digest</button>
</form>
<div id="progress" class="progress hidden">
<div class="spinner"></div>
<span id="progressText">Generating digest...</span>
</div>
<div id="results" class="results hidden">
<h3>Results</h3>
<div id="result"></div>
</div>
</div>
<script src="${scriptUri}"></script>
</body>
</html>`;
    }
}

================================================
FILE: src/utils/binary.ts
================================================
export class BinaryDetector {
    isBinary(buffer: Buffer): boolean {
        // Check first 1KB for binary indicators
        const sampleSize = Math.min(1024, buffer.length);
        const sample = buffer.subarray(0, sampleSize);

        // Check for null bytes
        if (sample.includes(0)) {
            return true;
        }

        // Check for high ratio of control characters
        let controlChars = 0;
        for (let i = 0; i < sample.length; i++) {
            const byte = sample[i];
            // Control characters (excluding common whitespace: \t, \n, \r)
            if ((byte < 32 && byte !== 9 && byte !== 10 && byte !== 13) || byte === 127) {
                controlChars++;
            }
        }

        const controlRatio = controlChars / sample.length;
        return controlRatio > 0.3; // More than 30% control chars = binary
    }
}


================================================
FILE: src/utils/DigestGenerator.ts
================================================
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
import { IgnoreFilter } from './ignore';
import { TreeBuilder } from './tree';
import { BinaryDetector } from './binary';
import { TokenEstimator } from './tokens';
import { minimatch } from 'minimatch';

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const stat = promisify(fs.stat);
const readdir = promisify(fs.readdir);
const lstat = promisify(fs.lstat);
const readlink = promisify(fs.readlink);

interface FileEntry {
    relativePath: string;
    fullPath: string;
    isSymlink: boolean;
    symlinkTarget?: string;
}

export class DigestGenerator {
    private config: vscode.WorkspaceConfiguration;
    private workspaceRoot: string;
    private ignoreFilter: IgnoreFilter;
    private treeBuilder: TreeBuilder;
    private binaryDetector: BinaryDetector;
    private tokenEstimator: TokenEstimator;

    constructor() {
        this.config = vscode.workspace.getConfiguration('codeDigest');
        this.workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath || '';
        this.ignoreFilter = new IgnoreFilter();
        this.treeBuilder = new TreeBuilder();
        this.binaryDetector = new BinaryDetector();
        this.tokenEstimator = new TokenEstimator();
    }

    async generateDigest(): Promise<void> {
        if (!this.workspaceRoot) {
            vscode.window.showErrorMessage('Please open a workspace folder first.');
            return;
        }

        try {
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: "Generating Code Digest",
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: "Scanning files..." });

                // Refresh config
                this.config = vscode.workspace.getConfiguration('codeDigest');

                // Initialize ignore filter
                if (this.config.get<boolean>('respectGitignore')) {
                    await this.ignoreFilter.initialize(this.workspaceRoot);
                }

                progress.report({ increment: 20, message: "Collecting files..." });

                // Collect files
                const files = await this.collectFiles();

                progress.report({ increment: 40, message: "Processing content..." });

                // Generate content
                const { summary, tree, content } = await this.processFiles(files);

                progress.report({ increment: 80, message: "Writing digest file..." });

                // Write output
                const outputPath = await this.writeDigest(summary, tree, content);

                progress.report({ increment: 100, message: "Complete!" });

                // Open the file
                const doc = await vscode.workspace.openTextDocument(outputPath);
                await vscode.window.showTextDocument(doc);

                vscode.window.showInformationMessage(
                    `Code digest generated: ${path.basename(outputPath)}`
                );
            });

        } catch (error) {
            const message = error instanceof Error ? error.message : 'Unknown error occurred';
            vscode.window.showErrorMessage(`Failed to generate digest: ${message}`);
        }
    }

    private async collectFiles(): Promise<FileEntry[]> {
        const files: FileEntry[] = [];
        const mode = this.config.get<string>('mode', 'curated');

        await this.traverseDirectory(this.workspaceRoot, '', files, mode);

        // Sort files by path
        files.sort((a, b) => a.relativePath.localeCompare(b.relativePath));

        return files;
    }

    private async traverseDirectory(
        fullPath: string,
        relativePath: string,
        files: FileEntry[],
        mode: string
    ): Promise<void> {
        try {
            const entries = await readdir(fullPath);

            for (const entry of entries) {
                const entryFullPath = path.join(fullPath, entry);
                const entryRelativePath = path.join(relativePath, entry).replace(/\\/g, '/');

                // Check if should skip
                if (this.shouldSkipEntry(entry, entryRelativePath, entryFullPath)) {
                    continue;
                }

                try {
                    const stats = await lstat(entryFullPath);

                    if (stats.isSymbolicLink()) {
                        let symlinkTarget: string | undefined;
                        try {
                            symlinkTarget = await readlink(entryFullPath);
                        } catch {
                            symlinkTarget = '<broken link>';
                        }

                        files.push({
                            relativePath: entryRelativePath,
                            fullPath: entryFullPath,
                            isSymlink: true,
                            symlinkTarget
                        });
                    } else if (stats.isDirectory()) {
                        await this.traverseDirectory(entryFullPath, entryRelativePath, files, mode);
                    } else if (stats.isFile()) {
                        if (this.shouldIncludeFile(entry, entryRelativePath, stats.size, mode)) {
                            files.push({
                                relativePath: entryRelativePath,
                                fullPath: entryFullPath,
                                isSymlink: false
                            });
                        }
                    }
                } catch (error) {
                    // Skip files we can't stat
                    console.warn(`Could not stat ${entryFullPath}:`, error);
                }
            }
        } catch (error) {
            console.warn(`Could not read directory ${fullPath}:`, error);
        }
    }

    private shouldSkipEntry(name: string, relativePath: string, fullPath: string): boolean {
        // Check .git directory
        if (name === '.git') {
            return !this.config.get<boolean>('includeGitDir');
        }

        // Check dotfiles
        if (name.startsWith('.') && !this.config.get<boolean>('includeDotfiles')) {
            return true;
        }

        // Check ignore patterns
        if (this.config.get<boolean>('respectGitignore')) {
            if (this.ignoreFilter.shouldIgnore(relativePath)) {
                return true;
            }
        }

        // Check additional exclude globs
        const excludeGlobs = this.config.get<string[]>('additionalExcludeGlobs', []);
        for (const glob of excludeGlobs) {
            if (minimatch(relativePath, glob)) {
                // Check if force-included
                const includeGlobs = this.config.get<string[]>('additionalIncludeGlobs', []);
                const forceIncluded = includeGlobs.some(includeGlob => 
                    minimatch(relativePath, includeGlob)
                );
                if (!forceIncluded) {
                    return true;
                }
            }
        }

        return false;
    }

    private shouldIncludeFile(name: string, relativePath: string, size: number, mode: string): boolean {
        // Check file size
        const maxSizeBytes = (this.config.get<number>('maxFileSizeKB', 10240) * 1024);
        if (size > maxSizeBytes) {
            return false;
        }

        // Exclude files that cannot be read in VS Code (images, videos, docs)
        const ext = require('path').extname(name).toLowerCase();
        const excludedExtensions = [
            // Images
            '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.ico', '.webp', '.tiff', '.svg',
            // Videos
            '.mp4', '.avi', '.mov', '.wmv', '.flv', '.mkv', '.webm', '.mpg', '.mpeg', '.3gp',
            // Audio
            '.mp3', '.wav', '.flac', '.ogg', '.aac', '.m4a', '.wma',
            // Documents
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.odt', '.ods', '.odp', '.rtf',
            // Archives
            '.zip', '.tar', '.gz', '.bz2', '.7z', '.rar', '.jar', '.war',
            // Executables
            '.exe', '.dll', '.so', '.dylib', '.bin', '.obj', '.o', '.a', '.lib'
        ];
        if (excludedExtensions.includes(ext)) {
            return false;
        }

        // Check additional include globs (force include)
        const includeGlobs = this.config.get<string[]>('additionalIncludeGlobs', []);
        if (includeGlobs.some(glob => minimatch(relativePath, glob))) {
            return true;
        }

        if (mode === 'curated') {
            return this.isCuratedFile(name, relativePath);
        } else if (mode === 'allText') {
            // For allText mode, we'll need to check if it's text-like
            // This is a heuristic - in practice you might want to read a small chunk
            return this.looksLikeTextFile(name);
        }

        return false;
    }

    private isCuratedFile(name: string, relativePath: string): boolean {
        const ext = path.extname(name).toLowerCase();
        const basename = path.basename(name);

        // Code file extensions
        const codeExtensions = [
            '.py', '.java', '.js', '.jsx', '.ts', '.tsx', '.c', '.h', '.cpp', '.cc', 
            '.cxx', '.hpp', '.hh', '.cs', '.swift', '.php', '.sql', '.rb', '.go', 
            '.kt', '.r', '.dart', '.rs', '.vue', '.svelte'
        ];

        if (codeExtensions.includes(ext)) {
            return true;
        }

        // Config and documentation files by name
        const configNames = [
            'package.json', 'pyproject.toml', 'go.mod', 'cargo.toml', 'gemfile',
            'requirements.txt', 'pipfile', 'makefile', 'dockerfile', 'procfile',
            '.gitignore', '.gitingestignore', '.gitkeep', '.editorconfig', 
            '.prettierrc', '.eslintrc', '.npmrc', '.yarnrc', '.python-version'
        ];

        const lowerName = basename.toLowerCase();
        if (configNames.some(config => lowerName.includes(config.replace('.', '')))) {
            return true;
        }

        // README, LICENSE, CHANGELOG files
        if (lowerName.startsWith('readme') || 
            lowerName.startsWith('license') || 
            lowerName.startsWith('changelog') ||
            lowerName.includes('license') ||
            lowerName === 'notice') {
            return true;
        }

        // Environment files
        if (lowerName.startsWith('.env')) {
            return true;
        }

        return false;
    }

    private looksLikeTextFile(name: string): boolean {
        const ext = path.extname(name).toLowerCase();
        
        // Known text extensions
        const textExtensions = [
            '.txt', '.md', '.rst', '.json', '.xml', '.yml', '.yaml', '.toml', 
            '.ini', '.cfg', '.conf', '.log', '.csv', '.tsv', '.html', '.htm', 
            '.css', '.scss', '.sass', '.less', '.svg'
        ];

        if (textExtensions.includes(ext)) {
            return true;
        }

        // Binary extensions to exclude
        const binaryExtensions = [
            '.exe', '.dll', '.so', '.dylib', '.bin', '.obj', '.o', '.a', '.lib',
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.svg', '.webp',
            '.mp3', '.mp4', '.avi', '.mov', '.wav', '.flac', '.ogg',
            '.zip', '.tar', '.gz', '.bz2', '.7z', '.rar', '.jar', '.war',
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx'
        ];

        if (binaryExtensions.includes(ext)) {
            return false;
        }

        // No extension or unknown extension - might be text
        return true;
    }

    private async processFiles(files: FileEntry[]): Promise<{
        summary: string;
        tree: string;
        content: string;
    }> {
        const rootName = path.basename(this.workspaceRoot);
        const timestamp = new Date().toISOString();
        
        // Build tree
        const tree = this.treeBuilder.buildTree(files, rootName);
        
        // Process file contents
        const contentBlocks: string[] = [];
        let processedCount = 0;

        for (const file of files) {
            const block = await this.processFileContent(file);
            if (block) {
                contentBlocks.push(block);
                processedCount++;
            }
        }

        const content = contentBlocks.join('\n');
        const fullText = tree + '\n' + content;
        const tokenEstimate = this.tokenEstimator.estimate(fullText);

        const summary = [
            `Directory: ${rootName}`,
            `Files analyzed: ${processedCount}`,
            `Generated: ${timestamp}`,
            `Estimated tokens: ${tokenEstimate}`
        ].join('\n');

        return { summary, tree, content };
    }

    private async processFileContent(file: FileEntry): Promise<string> {
        const separator = '='.repeat(48);
        
        try {
            if (file.isSymlink) {
                return [
                    separator,
                    `SYMLINK: ${file.relativePath} -> ${file.symlinkTarget}`,
                    separator,
                    '',
                    ''
                ].join('\n');
            }

            // Read file
            const buffer = await readFile(file.fullPath);
            
            // Check if binary
            const isBinary = this.binaryDetector.isBinary(buffer);
            const includeBinary = this.config.get<boolean>('includeBinary', false);
            
            let contentText: string;
            
            if (isBinary && !includeBinary) {
                contentText = '[Binary file]';
            } else if (isBinary && includeBinary) {
                try {
                    contentText = buffer.toString('utf8');
                } catch {
                    contentText = `Content (base64):\n${buffer.toString('base64')}`;
                }
            } else {
                contentText = buffer.toString('utf8');
            }

            // Apply markdown code fences if enabled and output is .md
            const outputFileName = this.config.get<string>('outputFileName', 'digest.txt');
            const useCodeFences = this.config.get<boolean>('markdownCodeFences', false) && 
                                 outputFileName.toLowerCase().endsWith('.md');
            
            if (useCodeFences && !isBinary) {
                const ext = path.extname(file.relativePath).slice(1);
                const language = this.getLanguageForExtension(ext);
                contentText = `\`\`\`${language}\n${contentText}\n\`\`\``;
            }

            return [
                separator,
                `FILE: ${file.relativePath}`,
                separator,
                contentText,
                ''
            ].join('\n');

        } catch (error) {
            return [
                separator,
                `FILE: ${file.relativePath}`,
                separator,
                `Error reading file: ${error instanceof Error ? error.message : 'Unknown error'}`,
                ''
            ].join('\n');
        }
    }

    private getLanguageForExtension(ext: string): string {
        const langMap: Record<string, string> = {
            'js': 'javascript',
            'jsx': 'javascript',
            'ts': 'typescript',
            'tsx': 'typescript',
            'py': 'python',
            'java': 'java',
            'c': 'c',
            'cpp': 'cpp',
            'cc': 'cpp',
            'cxx': 'cpp',
            'cs': 'csharp',
            'php': 'php',
            'rb': 'ruby',
            'go': 'go',
            'rs': 'rust',
            'swift': 'swift',
            'kt': 'kotlin',
            'dart': 'dart',
            'json': 'json',
            'xml': 'xml',
            'html': 'html',
            'css': 'css',
            'scss': 'scss',
            'yml': 'yaml',
            'yaml': 'yaml',
            'md': 'markdown',
            'sh': 'bash',
            'sql': 'sql'
        };
        
        return langMap[ext.toLowerCase()] || '';
    }

    private async writeDigest(summary: string, tree: string, content: string): Promise<string> {
        const outputFileName = this.config.get<string>('outputFileName', 'digest.txt');
        const outputPath = path.join(this.workspaceRoot, outputFileName);
        
        const fullContent = [
            summary,
            '',
            tree,
            '',
            content
        ].join('\n');

        await writeFile(outputPath, fullContent, 'utf8');
        
        return outputPath;
    }
}


================================================
FILE: src/utils/ignore.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import ignore, { Ignore } from 'ignore';

export class IgnoreFilter {
    private ignoreInstance: Ignore;
    private defaultIgnores: string[] = [
        'node_modules/**',
        'dist/**',
        'build/**',
        'target/**',
        'out/**',
        '.next/**',
        '.nuxt/**',
        '.venv/**',
        'venv/**',
        '.idea/**',
        '.vscode/**',
        '__pycache__/**',
        '.pytest_cache/**',
        'coverage/**',
        'logs/**',
        '*.log',
        'site-packages/**',
        '.DS_Store',
        'Thumbs.db'
    ];

    constructor() {
        this.ignoreInstance = ignore();
    }

    async initialize(rootPath: string): Promise<void> {
        // Add default ignores
        this.ignoreInstance.add(this.defaultIgnores);

        // Load .gitignore files
        await this.loadIgnoreFiles(rootPath, '.gitignore');
        await this.loadIgnoreFiles(rootPath, '.gitingestignore');
    }

    private async loadIgnoreFiles(rootPath: string, filename: string): Promise<void> {
        try {
            await this.walkDirectory(rootPath, async (dirPath) => {
                const ignoreFilePath = path.join(dirPath, filename);
                try {
                    const content = await fs.promises.readFile(ignoreFilePath, 'utf8');
                    const relativeDirPath = path.relative(rootPath, dirPath);
                    const patterns = content
                        .split('\n')
                        .map((line: string) => line.trim())
                        .filter((line: string) => line && !line.startsWith('#'))
                        .map((pattern: string) => {
                            if (relativeDirPath && !pattern.startsWith('/')) {
                                return path.join(relativeDirPath, pattern).replace(/\\/g, '/');
                            }
                            return pattern.startsWith('/') ? pattern.slice(1) : pattern;
                        });
                    
                    this.ignoreInstance.add(patterns);
                } catch {
                    // Ignore files that can't be read
                }
            });
        } catch {
            // Ignore directory traversal errors
        }
    }

    private async walkDirectory(dirPath: string, callback: (dir: string) => Promise<void>): Promise<void> {
        await callback(dirPath);
        
        try {
            const entries = await fs.promises.readdir(dirPath, { withFileTypes: true });
            
            for (const entry of entries) {
                if (entry.isDirectory() && entry.name !== '.git') {
                    const subDirPath = path.join(dirPath, entry.name);
                    await this.walkDirectory(subDirPath, callback);
                }
            }
        } catch {
            // Ignore directories we can't read
        }
    }

    shouldIgnore(relativePath: string): boolean {
        return this.ignoreInstance.ignores(relativePath);
    }
}


================================================
FILE: src/utils/tokens.ts
================================================
export class TokenEstimator {
    estimate(text: string): string {
        // Simple heuristic: tokens ‚âà words * 1.3
        const words = text.split(/\s+/).filter(word => word.length > 0).length;
        const tokens = Math.floor(words * 1.3);
        
        return this.humanizeNumber(tokens);
    }

    private humanizeNumber(num: number): string {
        if (num >= 1_000_000) {
            return `${(num / 1_000_000).toFixed(1)}M`;
        } else if (num >= 1_000) {
            return `${(num / 1_000).toFixed(1)}k`;
        } else {
            return num.toString();
        }
    }
}


================================================
FILE: src/utils/tree.ts
================================================
import * as path from 'path';

interface FileEntry {
    relativePath: string;
    fullPath: string;
    isSymlink: boolean;
    symlinkTarget?: string;
}

export class TreeBuilder {
    buildTree(files: FileEntry[], rootName: string): string {
        const tree = this.buildTreeStructure(files, rootName);
        return `Directory structure:\n${this.renderTree(tree)}`;
    }

    private buildTreeStructure(files: FileEntry[], rootName: string): TreeNode {
        const root: TreeNode = {
            name: rootName,
            isDirectory: true,
            children: new Map()
        };

        for (const file of files) {
            this.addToTree(root, file.relativePath, file.isSymlink);
        }

        return root;
    }

    private addToTree(root: TreeNode, relativePath: string, isSymlink: boolean): void {
        const parts = relativePath.split('/').filter(part => part);
        let current = root;

        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            const isLastPart = i === parts.length - 1;
            
            if (!current.children.has(part)) {
                current.children.set(part, {
                    name: part,
                    isDirectory: !isLastPart,
                    isSymlink: isLastPart ? isSymlink : false,
                    children: new Map()
                });
            }
            
            current = current.children.get(part)!;
        }
    }

    private renderTree(node: TreeNode, prefix: string = '', isLast: boolean = true): string {
        const lines: string[] = [];
        
        // Render current node
        const connector = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
        const displayName = node.isDirectory ? `${node.name}/` : node.name;
        const symlinkIndicator = node.isSymlink ? ' -> <target>' : '';
        
        lines.push(`${prefix}${connector}${displayName}${symlinkIndicator}`);

        // Render children
        const children = Array.from(node.children.values()).sort((a, b) => {
            // Directories first, then files
            if (a.isDirectory && !b.isDirectory) return -1;
            if (!a.isDirectory && b.isDirectory) return 1;
            return a.name.localeCompare(b.name);
        });

        children.forEach((child, index) => {
            const isLastChild = index === children.length - 1;
            const childPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
            lines.push(this.renderTree(child, childPrefix, isLastChild));
        });

        return lines.join('\n');
    }
}

interface TreeNode {
    name: string;
    isDirectory: boolean;
    isSymlink?: boolean;
    children: Map<string, TreeNode>;
}


================================================
FILE: src/webview/main.js
================================================
(function() {
    const vscode = acquireVsCodeApi();
    let currentSettings = {};

    // Get DOM elements
    const form = document.getElementById('digestForm');
    const generateBtn = document.getElementById('generateBtn');
    const progress = document.getElementById('progress');
    const results = document.getElementById('results');
    const openFileBtn = document.getElementById('openFileBtn');

    // Form elements
    const outputFileName = document.getElementById('outputFileName');
    const extTxt = document.getElementById('extTxt');
    const extMd = document.getElementById('extMd');
    const respectGitignore = document.getElementById('respectGitignore');
    const includeDotfiles = document.getElementById('includeDotfiles');
    const includeGitDir = document.getElementById('includeGitDir');
    const maxFileSizeKB = document.getElementById('maxFileSizeKB');
    const includeBinary = document.getElementById('includeBinary');
    const additionalIncludeGlobs = document.getElementById('additionalIncludeGlobs');
    const additionalExcludeGlobs = document.getElementById('additionalExcludeGlobs');
    const markdownCodeFences = document.getElementById('markdownCodeFences');
    const treeContent = document.getElementById('treeContent');
    const extCheckboxes = document.getElementById('extCheckboxes');

    // Listen for messages from extension
    window.addEventListener('message', event => {
        const message = event.data;
        switch (message.command) {
            case 'updateSettings':
                currentSettings = message.settings;
                updateFormFromSettings();
                break;
            case 'progress':
                updateProgress(message.text);
                break;
            case 'complete':
                showResults(message);
                break;
            case 'error':
                showError(message.error);
                break;
        }
    });

    function updateFormFromSettings() {
        // Only set filename (no extension)
        let fname = currentSettings.outputFileName || 'digest.txt';
        if (fname.endsWith('.txt')) fname = fname.slice(0, -4);
        if (fname.endsWith('.md')) fname = fname.slice(0, -3);
        outputFileName.value = fname;
        // Set extension checkboxes
        if (fname.endsWith('.md') || (currentSettings.outputFileName && currentSettings.outputFileName.endsWith('.md'))) {
            extMd.checked = true;
            extTxt.checked = false;
        } else {
            extTxt.checked = true;
            extMd.checked = false;
        }
        respectGitignore.checked = currentSettings.respectGitignore !== false;
        includeDotfiles.checked = currentSettings.includeDotfiles !== false;
        includeGitDir.checked = currentSettings.includeGitDir === true;
        maxFileSizeKB.value = currentSettings.maxFileSizeKB || 10240;
        includeBinary.checked = currentSettings.includeBinary === true;
        additionalIncludeGlobs.value = (currentSettings.additionalIncludeGlobs || []).join('\n');
        additionalExcludeGlobs.value = (currentSettings.additionalExcludeGlobs || []).join('\n');
        markdownCodeFences.checked = currentSettings.markdownCodeFences === true;
        // Render tree
        if (treeContent && currentSettings.tree) {
            treeContent.textContent = currentSettings.tree;
        }
        // Render extension checkboxes
        if (extCheckboxes && Array.isArray(currentSettings.extensions)) {
            extCheckboxes.innerHTML = '';
            currentSettings.extensions.forEach(ext => {
                const id = `ext_${ext}`;
                const label = document.createElement('label');
                label.className = 'ext-label';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = id;
                checkbox.value = ext;
                checkbox.checked = true;
                checkbox.className = 'ext-checkbox';
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(' .' + ext));
                extCheckboxes.appendChild(label);
            });
        }
    }

    function updateSetting(key, value) {
        vscode.postMessage({
            command: 'updateSetting',
            key: key,
            value: value
        });
    }

    // Add event listeners for form changes
    outputFileName.addEventListener('change', () => {
        let ext = extTxt.checked ? '.txt' : (extMd.checked ? '.md' : '.txt');
        updateSetting('outputFileName', outputFileName.value + ext);
    });
    extTxt.addEventListener('change', () => {
        if (extTxt.checked) {
            extMd.checked = false;
            updateSetting('outputFileName', outputFileName.value + '.txt');
        } else if (!extMd.checked) {
            extTxt.checked = true; // Always one selected
        }
    });
    extMd.addEventListener('change', () => {
        if (extMd.checked) {
            extTxt.checked = false;
            updateSetting('outputFileName', outputFileName.value + '.md');
        } else if (!extTxt.checked) {
            extMd.checked = true; // Always one selected
        }
    });
    // Remove mode logic
    respectGitignore.addEventListener('change', () => updateSetting('respectGitignore', respectGitignore.checked));
    includeDotfiles.addEventListener('change', () => updateSetting('includeDotfiles', includeDotfiles.checked));
    includeGitDir.addEventListener('change', () => updateSetting('includeGitDir', includeGitDir.checked));
    maxFileSizeKB.addEventListener('change', () => updateSetting('maxFileSizeKB', parseInt(maxFileSizeKB.value)));
    includeBinary.addEventListener('change', () => updateSetting('includeBinary', includeBinary.checked));
    markdownCodeFences.addEventListener('change', () => updateSetting('markdownCodeFences', markdownCodeFences.checked));

    additionalIncludeGlobs.addEventListener('change', () => {
        const globs = additionalIncludeGlobs.value.split('\n').filter(line => line.trim());
        updateSetting('additionalIncludeGlobs', globs);
    });

    additionalExcludeGlobs.addEventListener('change', () => {
        const globs = additionalExcludeGlobs.value.split('\n').filter(line => line.trim());
        updateSetting('additionalExcludeGlobs', globs);
    });

    // Generate button handler
    generateBtn.addEventListener('click', () => {
        showProgress();
        vscode.postMessage({
            command: 'generate'
        });
    });

    // Refresh button handler
    const refreshBtn = document.getElementById('refreshBtn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', () => {
            vscode.postMessage({ command: 'refreshExtension' });
        });
    }

    // Open file button handler
    openFileBtn.addEventListener('click', () => {
        vscode.postMessage({
            command: 'openFile'
        });
    });

    function showProgress() {
        progress.classList.remove('hidden');
        results.classList.add('hidden');
        generateBtn.disabled = true;
    }

    function updateProgress(text) {
        document.getElementById('progressText').textContent = text;
    }

    function showResults(data) {
        progress.classList.add('hidden');
        results.classList.remove('hidden');
        generateBtn.disabled = false;
        document.getElementById('resultsContent').innerHTML = `
            <p><strong>Files analyzed:</strong> ${data.fileCount}</p>
            <p><strong>Generated:</strong> ${data.outputPath}</p>
            <p><strong>Estimated tokens:</strong> ${data.tokenEstimate}</p>
        `;
        // Fully reset UI after showing results
        setTimeout(() => {
            results.classList.add('hidden');
            progress.classList.add('hidden');
            generateBtn.disabled = false;
            vscode.postMessage({ command: 'refreshExtension' });
        }, 2000);
    }

    function showError(error) {
        progress.classList.add('hidden');
        results.classList.remove('hidden');
        generateBtn.disabled = false;
        document.getElementById('resultsContent').innerHTML = `
            <div class="error">
                <strong>Error:</strong> ${error}
            </div>
        `;
        setTimeout(() => {
            results.classList.add('hidden');
            progress.classList.add('hidden');
            generateBtn.disabled = false;
        }, 2000);
    }
})();

